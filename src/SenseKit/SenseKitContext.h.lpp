/* ^^^AUTOGENHEADER^^^ */
#ifndef SENSEKITCONTEXT_H
#define SENSEKITCONTEXT_H

#include <SenseKit/sensekit_types.h>
#include <atomic>
#include <memory>
#include <unordered_map>
#include <string>

#include "PluginManager.h"
#include "StreamSet.h"
#include "StreamReader.h"
#include "Core/shared_library.h"
#include "Logger.h"
#include "StreamSetCatalog.h"

struct StreamServiceProxyBase;

namespace sensekit {

    class SenseKitContext
    {
    public:
        SenseKitContext() = default;
        SenseKitContext& operator=(const SenseKitContext& rhs) = delete;
        SenseKitContext(const SenseKitContext& context) = delete;

        sensekit_status_t initialize();
        sensekit_status_t terminate();

^^^BEGINREPLACE:stream^^^
        ^RETURN^ ^FUNC^(^PARAMS:ref^);

^^^ENDREPLACE^^^

        void raise_existing_streams_added(stream_added_callback_t callback, void* clientTag);

        StreamServiceProxyBase* get_streamServiceProxy() { return m_streamServiceProxy; }

        sensekit_status_t notify_host_event(sensekit_event_id id, const void* data, size_t dataSize);

        StreamSet& create_stream(const char* streamUri);

        StreamSetCatalog& get_setCatalog() { return m_setCatalog; }

    private:
        bool m_initialized{false};

        using LoggerPtr = std::unique_ptr<Logger>;
        LoggerPtr m_logger;

        StreamServiceProxyBase* m_streamServiceProxy;

        using PluginManagerPtr = std::unique_ptr<PluginManager>;
        PluginManagerPtr m_pluginManager;

        using ReaderPtr = std::unique_ptr<StreamReader>;
        using ReaderList = std::vector<ReaderPtr>;

        ReaderList m_readers;
        StreamSetCatalog m_setCatalog;
    };
}

#endif /* SENSEKITCONTEXT_H */
